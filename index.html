<!DOCTYPE html>

<html lang="ko">

<head>

<meta charset="UTF-8">

<title>독도 퍼즐 맞추기 (8조각)</title>

<style>

  body {

    background-color: #f0f8ff;

    display: flex;

    /* 화면 정 중앙 배치 유지 */

    justify-content: center;

    align-items: center;

    margin: 0;

    padding: 0; 

    flex-direction: column;

    min-height: 100vh; /* 전체 화면 높이 확보 */

    overflow: hidden; /* 스크롤바 방지 */

  }

  #gameCanvas {

    background-color: white;

    border: none;

    border-radius: 16px;

    display: block;

    position: relative;

    z-index: 10;

  }

</style>

</head>

<body>



<canvas id="gameCanvas" width="1200" height="700"></canvas> <script>

const canvas = document.getElementById("gameCanvas");

const ctx = canvas.getContext("2d");



// 크기 비율 변수: 0.35 (크기 유지)

const scale = 0.35;



// 미세 보정 값 설정 (크기 유지)

const ORIGINAL_SCALE = 0.41;

const SCALE_FACTOR = scale / ORIGINAL_SCALE;

const FINE_TUNE_X = 21 * SCALE_FACTOR;

const FINE_TUNE_Y_BOTTOM = 1 * SCALE_FACTOR;



// 이미지 로드

const backgroundImg = new Image();

backgroundImg.src = "./images/background.png";

const puzzleImgs = [];

for (let i = 1; i <= 8; i++) {

  const img = new Image();

  img.src = `./images/puzzle${i}.png`;

  puzzleImgs.push(img);

}

const winImg = new Image();

winImg.src = "./images/win.png";



// 사운드 로드

const fallSound = new Audio("./sounds/fall.mp3");

const successSound = new Audio("./sounds/success.mp3");



fallSound.volume = 1.0;

successSound.volume = 1.0;





// 크기 및 위치 계산

const bgWidth = 1920 * scale; 

const bgHeight = 1075 * scale; 



// 퍼즐 조각의 실제 그리기 크기

const puzzleWidth = 445 * scale * 1.01; 

const puzzleHeight = 506 * scale * 1.002; 



// 캔버스 중앙에 배경판을 배치하기 위한 offsetX와 offsetY 계산

const offsetX = (canvas.width - bgWidth) / 2; 

const offsetY = 20; // 정답판 시작 Y 위치



// 배경판의 최대 Y 좌표 (정답판 영역의 가장 낮은 위치)

const maxBgY = offsetY + bgHeight; // 약 396px



// 🚨 퍼즐 초기 위치 재설정: 퍼즐판과 조각 사이의 간격을 좁힘 (30px -> 10px로 가정)

const VERTICAL_GAP = 10; // 픽셀 단위로 간격 조정

const initialY_single_row = maxBgY + VERTICAL_GAP; // 약 396 + 10 = 406px



const unitW = 445 * scale;

const gapW = 19 * scale;

const startX = 36 * scale;

const startY1 = 24 * scale;

const gapH = 9 * scale;



const startY2 = offsetY + startY1 + puzzleHeight + gapH + FINE_TUNE_Y_BOTTOM;



// 목표 위치 배열 (배경판 기준)

const targetPositions = [

  // 윗줄 (1~4)

  {x: offsetX + startX, y: offsetY + startY1}, // 0 (조각 1)

  {x: offsetX + startX + unitW + gapW, y: offsetY + startY1}, // 1 (조각 2)

  {x: offsetX + startX + (unitW + gapW) * 2, y: offsetY + startY1}, // 2 (조각 3)

  {x: offsetX + startX + (unitW + gapW) * 3 + (unitW * 0.01), y: offsetY + startY1}, // 3 (조각 4)

  // 아랫줄 (5~8)

  {x: offsetX + startX, y: startY2}, // 4 (조각 5)

  {x: offsetX + startX + unitW + gapW, y: startY2}, // 5 (조각 6)

  {x: offsetX + startX + (unitW + gapW) * 2, y: startY2}, // 6 (조각 7)

  {x: offsetX + startX + (unitW + gapW) * 3 + (unitW * 0.01), y: startY2}, // 7 (조각 8)

];



// 초기 위치 배열 (캔버스 하단에 한 줄로 **겹쳐서** 배치)

const basePositions = [];

// 겹침 간격 설정: 조각 너비의 30%만 간격을 둠 (70% 겹침)

const overlapSpacing = puzzleWidth * 0.3; 

const totalPieces = 8;

const totalWidth = totalPieces * overlapSpacing + (puzzleWidth - overlapSpacing); // 8조각의 겹친 총 너비

const startBaseX = (canvas.width - totalWidth) / 2; // 중앙 정렬 시작 X 위치



for (let i = 0; i < totalPieces; i++) {

  // 모든 조각을 하나의 Y 위치에 배치

  basePositions.push({

    x: startBaseX + (i * overlapSpacing), // 겹침 간격 적용

    y: initialY_single_row // 🚨 좁혀진 Y 좌표 사용

  });

}





// 무작위 섞기

function shuffle(array) {

  for (let i = array.length - 1; i > 0; i--) {

    const j = Math.floor(Math.random() * (i + 1));

    [array[i], array[j]] = [array[j], array[i]];

  }

  return array;

}



const shuffledIndices = shuffle(Array.from({length: 8}, (_, i) => i));



// 퍼즐 객체 생성 시, 원본 인덱스를 저장합니다.

const puzzlePieces = shuffledIndices.map((originalIndex, shuffledPosIndex) => ({

  x: basePositions[shuffledPosIndex].x,

  y: basePositions[shuffledPosIndex].y,

  originalIndex: originalIndex,

  placed: false

}));





let dragging = false;

let dragIndex = -1;

let offsetDragX = 0, offsetDragY = 0;





function draw() {

  ctx.clearRect(0, 0, canvas.width, canvas.height);

  // 배경 이미지 중앙 배치

  ctx.drawImage(backgroundImg, offsetX, offsetY, bgWidth, bgHeight);



  // 퍼즐 그리기

  puzzlePieces.forEach((p, i) => {

    const img = puzzleImgs[p.originalIndex];

    let w = puzzleWidth;

    let h = puzzleHeight;

    

    if (p.originalIndex === 2 || p.originalIndex === 6) w *= 1.01;

    

    let drawX = p.x;

    if (p.originalIndex === 3 || p.originalIndex === 7) drawX -= FINE_TUNE_X;



    ctx.drawImage(img, drawX, p.y, w, h);

  });

}



// 드래그 시작

canvas.addEventListener("mousedown", e => {

  const mx = e.offsetX, my = e.offsetY;

  let found = false;

  

  for (let i = puzzlePieces.length - 1; i >= 0; i--) {

    const p = puzzlePieces[i];

    if (p.placed) continue;



    let checkX = p.x;

    if (p.originalIndex === 3 || p.originalIndex === 7) checkX -= FINE_TUNE_X;



    if (mx >= checkX && mx <= checkX + puzzleWidth &&

        my >= p.y && my <= p.y + puzzleHeight) {

      dragging = true;

      

      offsetDragX = mx - p.x;

      offsetDragY = my - p.y;

      

      // 드래그하는 조각을 맨 위로 올림

      const pieceToDrag = puzzlePieces.splice(i, 1)[0];

      puzzlePieces.push(pieceToDrag);

      dragIndex = puzzlePieces.length - 1;

      found = true;

      break;

    }

  }

  if (found) draw();

});





// 드래그 중

canvas.addEventListener("mousemove", e => {

  if (dragging && dragIndex !== -1) {

    const mx = e.offsetX, my = e.offsetY;

    puzzlePieces[dragIndex].x = mx - offsetDragX;

    puzzlePieces[dragIndex].y = my - offsetDragY;

    draw();

  }

});



// 드래그 끝

canvas.addEventListener("mouseup", () => {

  if (dragging && dragIndex !== -1) {

    const piece = puzzlePieces[dragIndex];

    

    const target = targetPositions[piece.originalIndex];

    // piece가 원래 있었던 basePositions의 인덱스 찾기

    const originalShuffledPosIndex = shuffledIndices.findIndex(val => val === piece.originalIndex);



    let correctedDropX = piece.x;

    if (piece.originalIndex === 3 || piece.originalIndex === 7) correctedDropX -= FINE_TUNE_X;



    const dx = correctedDropX - target.x;

    const dy = piece.y - target.y;



    const distance = Math.sqrt(dx * dx + dy * dy);

    const snapTolerance = 80;



    if (distance < snapTolerance) {

      // 최종 위치 설정 (정답 위치로 이동)

      piece.x = target.x;

      if (piece.originalIndex === 3 || piece.originalIndex === 7) {

            piece.x += FINE_TUNE_X;

        }

      piece.y = target.y;

      piece.placed = true;

      successSound.currentTime = 0;

      successSound.play();

      checkAllPlaced();

    } else {

      // 실패 시 원래 초기 위치로 복귀

      fallSound.currentTime = 0;

      fallSound.play();

      const startX = piece.x, startY = piece.y;

      const endX = basePositions[originalShuffledPosIndex].x; // piece가 원래 있었던 base 위치

      const endY = basePositions[originalShuffledPosIndex].y; // piece가 원래 있었던 base 위치

      let progress = 0;

      function returnAnim() {

        progress += 0.1;

        piece.x = startX + (endX - startX) * progress;

        piece.y = startY + (endY - startY) * progress;

        draw();

        if (progress < 1) requestAnimationFrame(returnAnim);

      }

      requestAnimationFrame(returnAnim);

    }

  }

  dragging = false;

  dragIndex = -1;

  draw();

});



// 퍼즐 완성 체크 및 애니메이션 함수

function checkAllPlaced() {

  if (puzzlePieces.filter(p => p.placed).length === 8) {

    canvas.style.pointerEvents = 'none';

    

    setTimeout(() => {

      successSound.currentTime = 0;

      successSound.play();

      startWipeAnimation(); // 애니메이션 실행

    }, 500);

  }

}



// '닦아내기' 애니메이션 함수

function startWipeAnimation() {

  let wipeProgress = 0;

  const duration = 120;

  let frame = 0;



  function animateWipe() {

    frame++;

    if (frame > duration) {

      // 애니메이션 종료 후 문구 표시 로직 삭제

      return;

    }



    wipeProgress = bgWidth * (frame / duration);



    ctx.clearRect(0, 0, canvas.width, canvas.height);

    

    ctx.drawImage(winImg, offsetX, offsetY, bgWidth, bgHeight);

    

    let clipX = offsetX + wipeProgress;

    let clipW = bgWidth - wipeProgress;

    

    ctx.fillStyle = 'white';

    ctx.fillRect(clipX, offsetY, clipW, bgHeight);



    requestAnimationFrame(animateWipe);

  }



  if (winImg.complete) {

    animateWipe();

  } else {

    winImg.onload = animateWipe;

  }

}





// 이미지 로드 후 시작

let loaded = 0;

const total = 1 + puzzleImgs.length + 1;

function checkLoaded() {

  loaded++;

  if (loaded === total) draw();

}

backgroundImg.onload = checkLoaded;

winImg.onload = checkLoaded;

puzzleImgs.forEach(img => img.onload = checkLoaded);

</script>

</body>

</html>