<!DOCTYPE html>

<html lang="ko">

<head>

<meta charset="UTF-8">

<title>ë…ë„ í¼ì¦ ë§ì¶”ê¸° (8ì¡°ê°)</title>

<style>

Â  body {

Â  Â  background-color: #f0f8ff;

Â  Â  display: flex;

Â  Â  /* í™”ë©´ ì • ì¤‘ì•™ ë°°ì¹˜ ìœ ì§€ */

Â  Â  justify-content: center;

Â  Â  align-items: center;

Â  Â  margin: 0;

Â  Â  padding: 0; 

Â  Â  flex-direction: column;

Â  Â  min-height: 100vh; /* ì „ì²´ í™”ë©´ ë†’ì´ í™•ë³´ */

Â  Â  overflow: hidden; /* ìŠ¤í¬ë¡¤ë°” ë°©ì§€ */

Â  }

Â  #gameCanvas {

Â  Â  background-color: white;

Â  Â  border: none;

Â  Â  border-radius: 16px;

Â  Â  display: block;

Â  Â  position: relative;

Â  Â  z-index: 10;

Â  }

</style>

</head>

<body>



<canvas id="gameCanvas" width="1200" height="700"></canvas> <script>

const canvas = document.getElementById("gameCanvas");

const ctx = canvas.getContext("2d");



// í¬ê¸° ë¹„ìœ¨ ë³€ìˆ˜: 0.35 (í¬ê¸° ìœ ì§€)

const scale = 0.35;



// ë¯¸ì„¸ ë³´ì • ê°’ ì„¤ì • (í¬ê¸° ìœ ì§€)

const ORIGINAL_SCALE = 0.41;

const SCALE_FACTOR = scale / ORIGINAL_SCALE;

const FINE_TUNE_X = 21 * SCALE_FACTOR;

const FINE_TUNE_Y_BOTTOM = 1 * SCALE_FACTOR;



// ì´ë¯¸ì§€ ë¡œë“œ

const backgroundImg = new Image();

backgroundImg.src = "./images/background.png";

const puzzleImgs = [];

for (let i = 1; i <= 8; i++) {

Â  const img = new Image();

Â  img.src = `./images/puzzle${i}.png`;

Â  puzzleImgs.push(img);

}

const winImg = new Image();

winImg.src = "./images/win.png";



// ì‚¬ìš´ë“œ ë¡œë“œ

const fallSound = new Audio("./sounds/fall.mp3");

const successSound = new Audio("./sounds/success.mp3");



fallSound.volume = 1.0;

successSound.volume = 1.0;





// í¬ê¸° ë° ìœ„ì¹˜ ê³„ì‚°

const bgWidth = 1920 * scale; 

const bgHeight = 1075 * scale; 



// í¼ì¦ ì¡°ê°ì˜ ì‹¤ì œ ê·¸ë¦¬ê¸° í¬ê¸°

const puzzleWidth = 445 * scale * 1.01; 

const puzzleHeight = 506 * scale * 1.002; 



// ìº”ë²„ìŠ¤ ì¤‘ì•™ì— ë°°ê²½íŒì„ ë°°ì¹˜í•˜ê¸° ìœ„í•œ offsetXì™€ offsetY ê³„ì‚°

const offsetX = (canvas.width - bgWidth) / 2; 

const offsetY = 20; // ì •ë‹µíŒ ì‹œì‘ Y ìœ„ì¹˜



// ë°°ê²½íŒì˜ ìµœëŒ€ Y ì¢Œí‘œ (ì •ë‹µíŒ ì˜ì—­ì˜ ê°€ì¥ ë‚®ì€ ìœ„ì¹˜)

const maxBgY = offsetY + bgHeight; // ì•½ 396px



// ğŸš¨ í¼ì¦ ì´ˆê¸° ìœ„ì¹˜ ì¬ì„¤ì •: í¼ì¦íŒê³¼ ì¡°ê° ì‚¬ì´ì˜ ê°„ê²©ì„ ì¢í˜ (30px -> 10pxë¡œ ê°€ì •)

const VERTICAL_GAP = 10; // í”½ì…€ ë‹¨ìœ„ë¡œ ê°„ê²© ì¡°ì •

const initialY_single_row = maxBgY + VERTICAL_GAP; // ì•½ 396 + 10 = 406px



const unitW = 445 * scale;

const gapW = 19 * scale;

const startX = 36 * scale;

const startY1 = 24 * scale;

const gapH = 9 * scale;



const startY2 = offsetY + startY1 + puzzleHeight + gapH + FINE_TUNE_Y_BOTTOM;



// ëª©í‘œ ìœ„ì¹˜ ë°°ì—´ (ë°°ê²½íŒ ê¸°ì¤€)

const targetPositions = [

Â  // ìœ—ì¤„ (1~4)

Â  {x: offsetX + startX, y: offsetY + startY1}, // 0 (ì¡°ê° 1)

Â  {x: offsetX + startX + unitW + gapW, y: offsetY + startY1}, // 1 (ì¡°ê° 2)

Â  {x: offsetX + startX + (unitW + gapW) * 2, y: offsetY + startY1}, // 2 (ì¡°ê° 3)

Â  {x: offsetX + startX + (unitW + gapW) * 3 + (unitW * 0.01), y: offsetY + startY1}, // 3 (ì¡°ê° 4)

Â  // ì•„ë«ì¤„ (5~8)

Â  {x: offsetX + startX, y: startY2}, // 4 (ì¡°ê° 5)

Â  {x: offsetX + startX + unitW + gapW, y: startY2}, // 5 (ì¡°ê° 6)

Â  {x: offsetX + startX + (unitW + gapW) * 2, y: startY2}, // 6 (ì¡°ê° 7)

Â  {x: offsetX + startX + (unitW + gapW) * 3 + (unitW * 0.01), y: startY2}, // 7 (ì¡°ê° 8)

];



// ì´ˆê¸° ìœ„ì¹˜ ë°°ì—´ (ìº”ë²„ìŠ¤ í•˜ë‹¨ì— í•œ ì¤„ë¡œ **ê²¹ì³ì„œ** ë°°ì¹˜)

const basePositions = [];

// ê²¹ì¹¨ ê°„ê²© ì„¤ì •: ì¡°ê° ë„ˆë¹„ì˜ 30%ë§Œ ê°„ê²©ì„ ë‘  (70% ê²¹ì¹¨)

const overlapSpacing = puzzleWidth * 0.3; 

const totalPieces = 8;

const totalWidth = totalPieces * overlapSpacing + (puzzleWidth - overlapSpacing); // 8ì¡°ê°ì˜ ê²¹ì¹œ ì´ ë„ˆë¹„

const startBaseX = (canvas.width - totalWidth) / 2; // ì¤‘ì•™ ì •ë ¬ ì‹œì‘ X ìœ„ì¹˜



for (let i = 0; i < totalPieces; i++) {

Â  // ëª¨ë“  ì¡°ê°ì„ í•˜ë‚˜ì˜ Y ìœ„ì¹˜ì— ë°°ì¹˜

Â  basePositions.push({

Â  Â  x: startBaseX + (i * overlapSpacing), // ê²¹ì¹¨ ê°„ê²© ì ìš©

Â  Â  y: initialY_single_row // ğŸš¨ ì¢í˜€ì§„ Y ì¢Œí‘œ ì‚¬ìš©

Â  });

}





// ë¬´ì‘ìœ„ ì„ê¸°

function shuffle(array) {

Â  for (let i = array.length - 1; i > 0; i--) {

Â  Â  const j = Math.floor(Math.random() * (i + 1));

Â  Â  [array[i], array[j]] = [array[j], array[i]];

Â  }

Â  return array;

}



const shuffledIndices = shuffle(Array.from({length: 8}, (_, i) => i));



// í¼ì¦ ê°ì²´ ìƒì„± ì‹œ, ì›ë³¸ ì¸ë±ìŠ¤ë¥¼ ì €ì¥í•©ë‹ˆë‹¤.

const puzzlePieces = shuffledIndices.map((originalIndex, shuffledPosIndex) => ({

Â  x: basePositions[shuffledPosIndex].x,

Â  y: basePositions[shuffledPosIndex].y,

Â  originalIndex: originalIndex,

Â  placed: false

}));





let dragging = false;

let dragIndex = -1;

let offsetDragX = 0, offsetDragY = 0;





function draw() {

Â  ctx.clearRect(0, 0, canvas.width, canvas.height);

Â  // ë°°ê²½ ì´ë¯¸ì§€ ì¤‘ì•™ ë°°ì¹˜

Â  ctx.drawImage(backgroundImg, offsetX, offsetY, bgWidth, bgHeight);



Â  // í¼ì¦ ê·¸ë¦¬ê¸°

Â  puzzlePieces.forEach((p, i) => {

Â  Â  const img = puzzleImgs[p.originalIndex];

Â  Â  let w = puzzleWidth;

Â  Â  let h = puzzleHeight;

Â  Â Â 

Â  Â  if (p.originalIndex === 2 || p.originalIndex === 6) w *= 1.01;

Â  Â Â 

Â  Â  let drawX = p.x;

Â  Â  if (p.originalIndex === 3 || p.originalIndex === 7) drawX -= FINE_TUNE_X;



Â  Â  ctx.drawImage(img, drawX, p.y, w, h);

Â  });

}



// ë“œë˜ê·¸ ì‹œì‘

canvas.addEventListener("mousedown", e => {

Â  const mx = e.offsetX, my = e.offsetY;

Â  let found = false;

Â Â 

Â  for (let i = puzzlePieces.length - 1; i >= 0; i--) {

Â  Â  const p = puzzlePieces[i];

Â  Â  if (p.placed) continue;



Â  Â  let checkX = p.x;

Â  Â  if (p.originalIndex === 3 || p.originalIndex === 7) checkX -= FINE_TUNE_X;



Â  Â  if (mx >= checkX && mx <= checkX + puzzleWidth &&

Â  Â  Â  Â  my >= p.y && my <= p.y + puzzleHeight) {

Â  Â  Â  dragging = true;

Â  Â  Â Â 

Â  Â  Â  offsetDragX = mx - p.x;

Â  Â  Â  offsetDragY = my - p.y;

Â  Â  Â Â 

Â  Â  Â  // ë“œë˜ê·¸í•˜ëŠ” ì¡°ê°ì„ ë§¨ ìœ„ë¡œ ì˜¬ë¦¼

Â  Â  Â  const pieceToDrag = puzzlePieces.splice(i, 1)[0];

Â  Â  Â  puzzlePieces.push(pieceToDrag);

Â  Â  Â  dragIndex = puzzlePieces.length - 1;

Â  Â  Â  found = true;

Â  Â  Â  break;

Â  Â  }

Â  }

Â  if (found) draw();

});





// ë“œë˜ê·¸ ì¤‘

canvas.addEventListener("mousemove", e => {

Â  if (dragging && dragIndex !== -1) {

Â  Â  const mx = e.offsetX, my = e.offsetY;

Â  Â  puzzlePieces[dragIndex].x = mx - offsetDragX;

Â  Â  puzzlePieces[dragIndex].y = my - offsetDragY;

Â  Â  draw();

Â  }

});



// ë“œë˜ê·¸ ë

canvas.addEventListener("mouseup", () => {

Â  if (dragging && dragIndex !== -1) {

Â  Â  const piece = puzzlePieces[dragIndex];

Â  Â Â 

Â  Â  const target = targetPositions[piece.originalIndex];

Â  Â  // pieceê°€ ì›ë˜ ìˆì—ˆë˜ basePositionsì˜ ì¸ë±ìŠ¤ ì°¾ê¸°

Â  Â  const originalShuffledPosIndex = shuffledIndices.findIndex(val => val === piece.originalIndex);



Â  Â  let correctedDropX = piece.x;

Â  Â  if (piece.originalIndex === 3 || piece.originalIndex === 7) correctedDropX -= FINE_TUNE_X;



Â  Â  const dx = correctedDropX - target.x;

Â  Â  const dy = piece.y - target.y;



Â  Â  const distance = Math.sqrt(dx * dx + dy * dy);

Â  Â  const snapTolerance = 80;



Â  Â  if (distance < snapTolerance) {

Â  Â  Â  // ìµœì¢… ìœ„ì¹˜ ì„¤ì • (ì •ë‹µ ìœ„ì¹˜ë¡œ ì´ë™)

Â  Â  Â  piece.x = target.x;

Â  Â  Â  if (piece.originalIndex === 3 || piece.originalIndex === 7) {

Â  Â  Â  Â  Â  Â  piece.x += FINE_TUNE_X;

Â  Â  Â  Â  }

Â  Â  Â  piece.y = target.y;

Â  Â  Â  piece.placed = true;

Â  Â  Â  successSound.currentTime = 0;

Â  Â  Â  successSound.play();

Â  Â  Â  checkAllPlaced();

Â  Â  } else {

Â  Â  Â  // ì‹¤íŒ¨ ì‹œ ì›ë˜ ì´ˆê¸° ìœ„ì¹˜ë¡œ ë³µê·€

Â  Â  Â  fallSound.currentTime = 0;

Â  Â  Â  fallSound.play();

Â  Â  Â  const startX = piece.x, startY = piece.y;

Â  Â  Â  const endX = basePositions[originalShuffledPosIndex].x; // pieceê°€ ì›ë˜ ìˆì—ˆë˜ base ìœ„ì¹˜

Â  Â  Â  const endY = basePositions[originalShuffledPosIndex].y; // pieceê°€ ì›ë˜ ìˆì—ˆë˜ base ìœ„ì¹˜

Â  Â  Â  let progress = 0;

Â  Â  Â  function returnAnim() {

Â  Â  Â  Â  progress += 0.1;

Â  Â  Â  Â  piece.x = startX + (endX - startX) * progress;

Â  Â  Â  Â  piece.y = startY + (endY - startY) * progress;

Â  Â  Â  Â  draw();

Â  Â  Â  Â  if (progress < 1) requestAnimationFrame(returnAnim);

Â  Â  Â  }

Â  Â  Â  requestAnimationFrame(returnAnim);

Â  Â  }

Â  }

Â  dragging = false;

Â  dragIndex = -1;

Â  draw();

});



// í¼ì¦ ì™„ì„± ì²´í¬ ë° ì• ë‹ˆë©”ì´ì…˜ í•¨ìˆ˜

function checkAllPlaced() {

Â  if (puzzlePieces.filter(p => p.placed).length === 8) {

Â  Â  canvas.style.pointerEvents = 'none';

Â  Â Â 

Â  Â  setTimeout(() => {

Â  Â  Â  successSound.currentTime = 0;

Â  Â  Â  successSound.play();

Â  Â  Â  startWipeAnimation(); // ì• ë‹ˆë©”ì´ì…˜ ì‹¤í–‰

Â  Â  }, 500);

Â  }

}



// 'ë‹¦ì•„ë‚´ê¸°' ì• ë‹ˆë©”ì´ì…˜ í•¨ìˆ˜

function startWipeAnimation() {

Â  let wipeProgress = 0;

Â  const duration = 120;

Â  let frame = 0;



Â  function animateWipe() {

Â  Â  frame++;

Â  Â  if (frame > duration) {

Â  Â  Â  // ì• ë‹ˆë©”ì´ì…˜ ì¢…ë£Œ í›„ ë¬¸êµ¬ í‘œì‹œ ë¡œì§ ì‚­ì œ

Â  Â  Â  return;

Â  Â  }



Â  Â  wipeProgress = bgWidth * (frame / duration);



Â  Â  ctx.clearRect(0, 0, canvas.width, canvas.height);

Â  Â Â 

Â  Â  ctx.drawImage(winImg, offsetX, offsetY, bgWidth, bgHeight);

Â  Â Â 

Â  Â  let clipX = offsetX + wipeProgress;

Â  Â  let clipW = bgWidth - wipeProgress;

Â  Â Â 

Â  Â  ctx.fillStyle = 'white';

Â  Â  ctx.fillRect(clipX, offsetY, clipW, bgHeight);



Â  Â  requestAnimationFrame(animateWipe);

Â  }



Â  if (winImg.complete) {

Â  Â  animateWipe();

Â  } else {

Â  Â  winImg.onload = animateWipe;

Â  }

}





// ì´ë¯¸ì§€ ë¡œë“œ í›„ ì‹œì‘

let loaded = 0;

const total = 1 + puzzleImgs.length + 1;

function checkLoaded() {

Â  loaded++;

Â  if (loaded === total) draw();

}

backgroundImg.onload = checkLoaded;

winImg.onload = checkLoaded;

puzzleImgs.forEach(img => img.onload = checkLoaded);

</script>

</body>

</html>