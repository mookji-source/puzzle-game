<!DOCTYPE html>

<html lang="ko">

<head>

<meta charset="UTF-8">

<title>ë…ë„ í¼ì¦ ë§ì¶”ê¸° (8ì¡°ê°)</title>

<style>

  body {

    background-color: #f0f8ff;

    display: flex;

    /* ìº”ë²„ìŠ¤ê°€ ìƒë‹¨ì— ë°°ì¹˜ë˜ê³  ë¬¸êµ¬ëŠ” ê·¸ ì•„ë˜ì— ë¶™ë„ë¡ ìƒë‹¨ ì •ë ¬ ìœ ì§€ */

    justify-content: flex-start; 

    align-items: center; 

    margin: 0; 

    padding: 20px 0; /* ìº”ë²„ìŠ¤ì™€ ë¬¸êµ¬ì˜ ìƒí•˜ ì—¬ë°± í™•ë³´ */

    flex-direction: column; 

    min-height: 100vh; /* ì „ì²´ í™”ë©´ ë†’ì´ í™•ë³´ */

    position: relative;

  }

  #gameCanvas {

    background-color: white;

    border: none;

    border-radius: 16px;

    display: block;

    margin: 0 auto;

    position: relative;

    z-index: 10;

  }

  /* ìŠ¹ë¦¬ ë©”ì‹œì§€ ì˜¤ë²„ë ˆì´ ìŠ¤íƒ€ì¼ (ê·¸ë¦¼ ë°”ë¡œ ì•„ë˜ì— ë°°ì¹˜) */

  #winOverlay {

    display: none; /* ğŸš¨ ì´ˆê¸°ì—ëŠ” ìˆ¨ê¹€ */

    width: 1300px; /* ìº”ë²„ìŠ¤ ë„ˆë¹„ì™€ ë™ì¼í•˜ê²Œ ì„¤ì •í•˜ì—¬ ì¤‘ì•™ ì •ë ¬ ìœ ì§€ */

    margin-top: 20px; /* ê·¸ë¦¼ ì•„ë˜ ì ì ˆí•œ ê°„ê²© */

    z-index: 20; 

    justify-content: center;

    align-items: center;

    flex-direction: column;

    text-align: center; 

  }

  #winMessage {

    color: #0b3b8c; 

    font-size: 48px; /* ğŸš¨ í¬ê¸°ë¥¼ ì¡°ê¸ˆ ì¤„ì—¬ ê¹”ë”í•˜ê²Œ ë³´ì´ë„ë¡ ì¡°ì • */

    font-family: 'Arial Black', sans-serif;

    padding: 20px 40px;

    border-radius: 10px;

    background-color: rgba(255, 255, 255, 0.9);

    box-shadow: 0 0 10px rgba(0, 0, 0, 0.1);

  }

</style>

</head>

<body>



<canvas id="gameCanvas" width="1300" height="800"></canvas>



<div id="winOverlay">

    <div id="winMessage">ëª¨ë“  í¼ì¦ì„ ì™„ì„±í–ˆìŠµë‹ˆë‹¤.</div>

</div>



<script>

const canvas = document.getElementById("gameCanvas");

const ctx = canvas.getContext("2d");

const winOverlay = document.getElementById("winOverlay"); // ğŸš¨ winOverlay ë³€ìˆ˜ ë³µêµ¬



// í¬ê¸° ë¹„ìœ¨ ë³€ìˆ˜: 0.41

const scale = 0.41;



// ë¯¸ì„¸ ë³´ì • ê°’ ì„¤ì • (ì •ë ¬ì€ ê·¸ëŒ€ë¡œ ìœ ì§€)

const FINE_TUNE_X = 21; 

const FINE_TUNE_Y_BOTTOM = 1; 



// ì´ë¯¸ì§€ ë¡œë“œ

const backgroundImg = new Image();

backgroundImg.src = "./images/background.png";

const puzzleImgs = [];

for (let i = 1; i <= 8; i++) {

  const img = new Image();

  img.src = `./images/puzzle${i}.png`;

  puzzleImgs.push(img);

}

const winImg = new Image();

winImg.src = "./images/win.png"; 



// ì‚¬ìš´ë“œ ë¡œë“œ

const fallSound = new Audio("./sounds/fall.mp3");

const successSound = new Audio("./sounds/success.mp3");

// seagullsSound, seaSoundëŠ” ë¬¸êµ¬ì™€ í•¨ê»˜ ì‚­ì œ ìƒíƒœ ìœ ì§€



fallSound.volume = 1.0;

successSound.volume = 1.0;





// í¬ê¸° ë° ìœ„ì¹˜ ê³„ì‚°

const bgWidth = 1920 * scale; 

const bgHeight = 1075 * scale; 



const puzzleWidth = 445 * scale * 1.01; 

const puzzleHeight = 506 * scale * 1.002; 



const offsetX = (canvas.width - bgWidth) / 2;

// ë°°ê²½íŒ Y ìœ„ì¹˜: 5

const offsetY = 5; 



// ë°°ê²½íŒì˜ ìµœëŒ€ Y ì¢Œí‘œ (ê°€ì¥ ë‚®ì€ ìœ„ì¹˜)

const maxBgY = offsetY + bgHeight; 



// í¼ì¦ ì´ˆê¸° ìœ„ì¹˜ë¥¼ ë°°ê²½íŒ ë°”ë¡œ ì•„ë˜ë¡œ ë³µêµ¬ (ìš”ì²­ì‚¬í•­ ë°˜ì˜)

const initialY = maxBgY + 10; // ë°°ê²½íŒ ë°”ë¡œ ì•„ë˜ (ì²«ì§¸ ì¤„)

const initialY_row2 = initialY + puzzleHeight + 10; // ë‘˜ì§¸ ì¤„



const unitW = 445 * scale; 

const gapW = 19 * scale;   

const startX = 36 * scale; 

const startY1 = 24 * scale; 

const gapH = 9 * scale; 



const startY2 = offsetY + startY1 + puzzleHeight + gapH + FINE_TUNE_Y_BOTTOM;



// ëª©í‘œ ìœ„ì¹˜ ë°°ì—´

const targetPositions = [

  // ìœ—ì¤„ (1~4)

  {x: offsetX + startX, y: offsetY + startY1}, // 0 (ì¡°ê° 1)

  {x: offsetX + startX + unitW + gapW, y: offsetY + startY1}, // 1 (ì¡°ê° 2)

  {x: offsetX + startX + (unitW + gapW) * 2, y: offsetY + startY1}, // 2 (ì¡°ê° 3) 

  {x: offsetX + startX + (unitW + gapW) * 3 + (unitW * 0.01), y: offsetY + startY1}, // 3 (ì¡°ê° 4) 

  // ì•„ë«ì¤„ (5~8)

  {x: offsetX + startX, y: startY2}, // 4 (ì¡°ê° 5) 

  {x: offsetX + startX + unitW + gapW, y: startY2}, // 5 (ì¡°ê° 6) 

  {x: offsetX + startX + (unitW + gapW) * 2, y: startY2}, // 6 (ì¡°ê° 7) 

  {x: offsetX + startX + (unitW + gapW) * 3 + (unitW * 0.01), y: startY2}, // 7 (ì¡°ê° 8) 

];



// ì´ˆê¸° ìœ„ì¹˜ ë°°ì—´

const basePositions = [];

const row1StartX = 50; 

const row2StartX = canvas.width - (4 * (unitW + 10)) - 50; 



for (let i = 0; i < 8; i++) {

  if (i < 4) {

    basePositions.push({

      x: row1StartX + (i * (unitW + 10)),

      y: initialY  

    });

  } else {

    basePositions.push({

      x: row2StartX + ((i - 4) * (unitW + 10)),

      y: initialY_row2 

    });

  }

}





// ë¬´ì‘ìœ„ ì„ê¸° (basePositionsì˜ ì‚¬ë³¸ì„ ì„ìŠµë‹ˆë‹¤.)

function shuffle(array) {

  for (let i = array.length - 1; i > 0; i--) {

    const j = Math.floor(Math.random() * (i + 1));

    [array[i], array[j]] = [array[j], array[i]];

  }

  return array;

}



const shuffledIndices = shuffle(Array.from({length: 8}, (_, i) => i));



// í¼ì¦ ê°ì²´ ìƒì„± ì‹œ, ì›ë³¸ ì¸ë±ìŠ¤ë¥¼ ì €ì¥í•©ë‹ˆë‹¤.

const puzzlePieces = shuffledIndices.map((originalIndex, shuffledPosIndex) => ({

  x: basePositions[shuffledPosIndex].x, 

  y: basePositions[shuffledPosIndex].y,

  originalIndex: originalIndex, 

  placed: false

}));





let dragging = false;

let dragIndex = -1;

let offsetDragX = 0, offsetDragY = 0;





function draw() {

  ctx.clearRect(0, 0, canvas.width, canvas.height);

  ctx.drawImage(backgroundImg, offsetX, offsetY, bgWidth, bgHeight);



  // í¼ì¦ ê·¸ë¦¬ê¸° 

  puzzlePieces.forEach((p, i) => { 

    const img = puzzleImgs[p.originalIndex]; 

    let w = puzzleWidth;

    let h = puzzleHeight;

    

    if (p.originalIndex === 2 || p.originalIndex === 6) w *= 1.01;

    

    let drawX = p.x;

    if (p.originalIndex === 3 || p.originalIndex === 7) drawX -= FINE_TUNE_X;



    ctx.drawImage(img, drawX, p.y, w, h);

  });

}



// ë“œë˜ê·¸ ì‹œì‘

canvas.addEventListener("mousedown", e => {

  const mx = e.offsetX, my = e.offsetY;

  let found = false;

  

  for (let i = puzzlePieces.length - 1; i >= 0; i--) {

    const p = puzzlePieces[i];

    if (p.placed) continue;



    let checkX = p.x;

    if (p.originalIndex === 3 || p.originalIndex === 7) checkX -= FINE_TUNE_X;



    if (mx >= checkX && mx <= checkX + puzzleWidth &&

        my >= p.y && my <= p.y + puzzleHeight) {

      dragging = true;

      

      offsetDragX = mx - p.x;

      offsetDragY = my - p.y;

      

      const pieceToDrag = puzzlePieces.splice(i, 1)[0];

      puzzlePieces.push(pieceToDrag);

      dragIndex = puzzlePieces.length - 1;

      found = true;

      break;

    }

  }

  if (found) draw();

});





// ë“œë˜ê·¸ ì¤‘

canvas.addEventListener("mousemove", e => {

  if (dragging && dragIndex !== -1) {

    const mx = e.offsetX, my = e.offsetY;

    puzzlePieces[dragIndex].x = mx - offsetDragX;

    puzzlePieces[dragIndex].y = my - offsetDragY;

    draw();

  }

});



// ë“œë˜ê·¸ ë

canvas.addEventListener("mouseup", () => {

  if (dragging && dragIndex !== -1) {

    const piece = puzzlePieces[dragIndex];

    

    const target = targetPositions[piece.originalIndex];

    const base = basePositions[piece.originalIndex];



    let correctedDropX = piece.x;

    if (piece.originalIndex === 3 || piece.originalIndex === 7) correctedDropX -= FINE_TUNE_X;



    const dx = correctedDropX - target.x; 

    const dy = piece.y - target.y;



    const distance = Math.sqrt(dx * dx + dy * dy);

    const snapTolerance = 80; 



    if (distance < snapTolerance) {

      // ìµœì¢… ìœ„ì¹˜ ì„¤ì • (ì •ë‹µ ìœ„ì¹˜ë¡œ ì´ë™)

      piece.x = target.x;

      if (piece.originalIndex === 3 || piece.originalIndex === 7) {

            piece.x += FINE_TUNE_X; 

        }

      piece.y = target.y; 

      piece.placed = true;

      successSound.currentTime = 0;

      successSound.play();

      checkAllPlaced();

    } else {

      // ì‹¤íŒ¨ ì‹œ ì›ë˜ ì´ˆê¸° ìœ„ì¹˜ë¡œ ë³µê·€

      fallSound.currentTime = 0;

      fallSound.play();

      const startX = piece.x, startY = piece.y;

      const endX = base.x;

      const endY = base.y;

      let progress = 0;

      function returnAnim() {

        progress += 0.1;

        piece.x = startX + (endX - startX) * progress;

        piece.y = startY + (endY - startY) * progress;

        draw();

        if (progress < 1) requestAnimationFrame(returnAnim);

      }

      requestAnimationFrame(returnAnim);

    }

  }

  dragging = false;

  dragIndex = -1;

  draw();

});



// í¼ì¦ ì™„ì„± ì²´í¬ ë° ì• ë‹ˆë©”ì´ì…˜ í•¨ìˆ˜

function checkAllPlaced() {

  if (puzzlePieces.filter(p => p.placed).length === 8) {

    canvas.style.pointerEvents = 'none'; 

    

    setTimeout(() => {

      successSound.currentTime = 0;

      successSound.play();

      startWipeAnimation(); // ì• ë‹ˆë©”ì´ì…˜ ì‹¤í–‰

    }, 500);

  }

}



// 'ë‹¦ì•„ë‚´ê¸°' ì• ë‹ˆë©”ì´ì…˜ í•¨ìˆ˜

function startWipeAnimation() {

  let wipeProgress = 0;

  const duration = 120; 

  let frame = 0;



  function animateWipe() {

    frame++;

    if (frame > duration) {

      // ì• ë‹ˆë©”ì´ì…˜ ì¢…ë£Œ í›„ ë¬¸êµ¬ í‘œì‹œ

      setTimeout(() => {

            winOverlay.style.display = 'flex'; // ğŸš¨ ë¬¸êµ¬ í‘œì‹œ

        }, 100);

      return;

    }



    wipeProgress = bgWidth * (frame / duration); 



    ctx.clearRect(0, 0, canvas.width, canvas.height);

    

    ctx.drawImage(winImg, offsetX, offsetY, bgWidth, bgHeight);

    

    let clipX = offsetX + wipeProgress;

    let clipW = bgWidth - wipeProgress;

    

    ctx.fillStyle = 'white'; 

    ctx.fillRect(clipX, offsetY, clipW, bgHeight);



    requestAnimationFrame(animateWipe);

  }



  if (winImg.complete) {

    animateWipe();

  } else {

    winImg.onload = animateWipe;

  }

}





// ì´ë¯¸ì§€ ë¡œë“œ í›„ ì‹œì‘

let loaded = 0;

const total = 1 + puzzleImgs.length + 1; 

function checkLoaded() {

  loaded++;

  if (loaded === total) draw();

}

backgroundImg.onload = checkLoaded;

winImg.onload = checkLoaded; 

puzzleImgs.forEach(img => img.onload = checkLoaded);

</script>

</body>

</html>
/*    /index.html   200